opt_out_usage

# Global variables to simplify the individual adjustment
PROJECT_NAME = "Uniswap"
ONE_SIGNAL_TARGET_NAME = "OneSignalNotificationServiceExtension"
WIDGET_TARGET_NAME = "Widgets"
WIDGET_INTENT_TARGET_NAME = "WidgetIntentExtension"
XCODE_PROJECT = "./ios/#{PROJECT_NAME}.xcodeproj"
XCODE_WORKSPACE = "./ios/#{PROJECT_NAME}.xcworkspace"
ANDROID_GRADLE_BUILD_FILE = "./android/app/build.gradle"
OUTPUT_DIRECTORY = "./fastlane/builds/"
BUILD_ONLY = false

platform :android do

  lane :buildAndUpload do

    running_on_ci = ENV["CI"] || false
    # Ensure flavor, package name, and json key data are set
    if ENV["ANDROID_FLAVOR"].nil? || ENV["ANDROID_PACKAGE_NAME"].nil? || ENV["ANDROID_JSON_KEY_DATA"].nil?
      UI.user_error!("Flavor, package name, and json key data must be set")
    end

    flavor = ENV["ANDROID_FLAVOR"]
    package_name = ENV["ANDROID_PACKAGE_NAME"]
    json_key_data = ENV["ANDROID_JSON_KEY_DATA"]

    version_name = get_version_name_for_flavor(flavor, "./../#{ANDROID_GRADLE_BUILD_FILE}")

    # Convert the version string to the corresponding decimal number 
    # (e.g. 1.0.0 -> 10000000, where 1.000.00.00 represents major.minor.patch.build)
    version_name_decimal = version_name.to_f
    major_minor_patch_number = version_name_decimal * 10000000 / 100 

    version_codes = google_play_track_version_codes(
      json_key_data: json_key_data,
      package_name: package_name,
      track: "internal" # Will be first uploaded to internal track
    )
    
    matching_version_codes = []
    for version_code in version_codes
      if (version_code.to_s.start_with?(major_minor_patch_number.to_i.to_s)) 
        matching_version_codes.push(version_code)
      end
    end

    # If there are no matching version codes, then this is the first time uploading to the internal track
    next_version_code = major_minor_patch_number * 100 + 1
    if !matching_version_codes.empty?
      max_version_code = matching_version_codes.max
      next_version_code = max_version_code + 1
    end
    
    # Set the version code in the build.gradle file before building. 
    # This sets the value under defaultConfig because the flavors don't have a versionCode property specified, 
    # and we usually don't need to record it in our codebase after building.
    android_set_version_code(
      gradle_file: ANDROID_GRADLE_BUILD_FILE,
      version_code: next_version_code.to_i
    )

    if running_on_ci
      sh "echo ANDROID_VERSION_CODE=#{next_version_code} >> $GITHUB_ENV"
    end
    
    gradle(
      task: 'bundle',
      build_type: 'Release',
      flavor: flavor,
      gradle_path: './gradlew',
      project_dir: './android'
    )

    aab_path = "./android/app/build/outputs/bundle/#{flavor}Release/app-#{flavor}-release.aab"

    upload_to_play_store(
      track: 'internal', 
      aab: aab_path,
      skip_upload_apk: true, # only uplaod aab, not apk
      release_status: 'draft',
      json_key_data: json_key_data, 
      package_name: package_name
    )
  end

  def get_version_name_for_flavor(flavor, build_gradle_path)
    # Read the build.gradle file
    content = File.read(build_gradle_path)
    
    # Use regex with named capture group to capture the versionName after the productFlavor declaration
    match = content.match(/#{flavor}\s*{[^}]*versionName\s+"(?<versionName>[^"]+)"/m)
    
    # If matched, return the captured versionName, otherwise return nil
    match ? match[:versionName] : nil
  end

end

platform :ios do
  before_all do
  end

  private_lane :certificates do | options |
    match_type = options[:match_type]

    if options[:ci]
      create_keychain(
        name: ENV["CI_KEYCHAIN_NAME"],
        password: ENV["CI_KEYCHAIN_PASSWORD"],
        default_keychain: true,
        unlock: true,
        timeout: 3600,
        lock_when_sleeps: false
      )
      match(
        type: match_type,
        keychain_name: ENV["CI_KEYCHAIN_NAME"],
        keychain_password: ENV["CI_KEYCHAIN_PASSWORD"],
        readonly: true,
        shallow_clone: true,
        verbose: false,
        clone_branch_directly: true,
      )
    else
      match(
        type: match_type,
        readonly: true,
        shallow_clone: true,
        verbose: false,
        clone_branch_directly: true,
      )
    end

  end

  lane :update_build_numbers_for_configuration do |option|
        
    fastlane_require 'Xcodeproj'
    
    configuration = option[:configuration]
    new_build_number = option[:new_build_number]
    
    project = Xcodeproj::Project.open("../" + XCODE_PROJECT)
    project.targets.each do |mtarget|
      if mtarget.name == PROJECT_NAME || mtarget.name == ONE_SIGNAL_TARGET_NAME || mtarget.name == WIDGET_TARGET_NAME || mtarget.name == WIDGET_INTENT_TARGET_NAME
          mtarget.build_configurations.each do |mbuild|
            if mbuild.name == configuration
                mbuild.build_settings['CURRENT_PROJECT_VERSION'] = new_build_number
            end
          end
      end
    end
    project.save()
    new_build_number
end

  lane :build do | options |
    match_type = "appstore"

    certificates(
      ci: options[:running_on_ci],
      match_type: match_type,
    )

    sh("cd ../fastlane") # yarn and pod install should be done by previous step of github actions

    build_app(
      scheme: PROJECT_NAME,
      workspace: XCODE_WORKSPACE,
      silent: true,
      clean: true,
      configuration: options[:configuration],
      output_directory: OUTPUT_DIRECTORY,
      output_name: "#{PROJECT_NAME}.ipa",
      export_method: "app-store",
    )

    match_type
  end

  private_lane :ship do | options |
    pilot(
      api_key: options[:api_key],
      ipa: "#{OUTPUT_DIRECTORY}#{PROJECT_NAME}.ipa",
      skip_waiting_for_build_processing: true,
      verbose: false,
      uses_non_exempt_encryption: true,
      notify_external_testers: false,
      team_id: options[:apple_team_id],
      apple_id: options[:apple_app_id],
      itc_provider: ENV["sigh_#{options[:app_identifier]}_#{options[:match_type]}_team-id"],
    )
  end

  lane :buildAndShip do
    running_on_ci = ENV["CI"] || false
    configuration = ENV["CONFIGURATION"] || "Dev"

    api_key = app_store_connect_api_key(
      key_id: ENV["APP_STORE_CONNECT_KEY_ID"],
      issuer_id: ENV["APP_STORE_CONNECT_ISSUER_ID"],
      key_content: ENV["APP_STORE_CONNECT_KEY_CONTENT"],
    )

    options = {
      :api_key => api_key,
      :app_identifier => ENV["APP_IDENTIFIER"], # app identifier depends on configuration
      :apple_team_id => ENV["APPLE_TEAM_ID"],
      :apple_app_id => ENV["APPLE_APP_ID"], # app id depends on configuration
      :configuration => configuration,
      :git_branch_name => running_on_ci ? "#{ENV['GIT_BRANCH_NAME']}"  : sh("git", "rev-parse", "--abbrev-ref", "HEAD", log: false),
      :running_on_ci => running_on_ci,
    }

    current_marketing_version = get_version_number(
      xcodeproj: XCODE_PROJECT,
      target: PROJECT_NAME,
      configuration: configuration
    )

    current_build_number = latest_testflight_build_number(
      api_key: api_key,
      version: current_marketing_version,
      app_identifier: ENV["APP_IDENTIFIER"],
      initial_build_number: 0, # used if a build does not exist for the current version
      )

    new_build_number = update_build_numbers_for_configuration(
      configuration: configuration,
      new_build_number: current_build_number + 1
    )

    # Setting env variables to be used in the next step of the workflow
    if running_on_ci
      sh "echo IOS_BUILD_NUMBER=#{new_build_number} >> $GITHUB_ENV"
      sh "echo IOS_VERSION_NUMBER=#{current_marketing_version} >> $GITHUB_ENV"
    end

    match_type = build(options)

    unless BUILD_ONLY
      ship(
        api_key: api_key,
        apple_team_id: options[:apple_team_id],
        apple_app_id: options[:apple_app_id],
        app_identifier: options[:app_identifier],
        match_type: match_type,
      )
    end
  end

  # bulk action to update build numbers for all configurations pulled from TestFlight
  lane :update_build_numbers do

    api_key = app_store_connect_api_key(
      key_id: ENV["APP_STORE_CONNECT_KEY_ID"],
      issuer_id: ENV["APP_STORE_CONNECT_ISSUER_ID"],
      key_content: ENV["APP_STORE_CONNECT_KEY_CONTENT"],
    )

    current_marketing_version = get_version_number(
      xcodeproj: XCODE_PROJECT,
      target: PROJECT_NAME,
      configuration: ENV["CONFIGURATION"]
    )

    current_build_number = latest_testflight_build_number(
      api_key: api_key,
      version: current_marketing_version,
      app_identifier: ENV["APP_IDENTIFIER"],
      )

    new_build_number = update_build_numbers_for_configuration(
      configuration: ENV["CONFIGURATION"],
      new_build_number: current_build_number
    )

    begin
      commit_version_bump(
        xcodeproj: XCODE_PROJECT,
      )
    rescue => e
      # no-op if there is nothing to commit
    end

  end

  # get version for release candiate
  lane :getMarketingVersionNumber do

    api_key = app_store_connect_api_key(
      key_id: ENV["APP_STORE_CONNECT_KEY_ID"],
      issuer_id: ENV["APP_STORE_CONNECT_ISSUER_ID"],
      key_content: ENV["APP_STORE_CONNECT_KEY_CONTENT"],
    )

    current_marketing_version = get_version_number(
      xcodeproj: XCODE_PROJECT,
      target: PROJECT_NAME,
      configuration: "Release"
    )

    # Setting env variables to be used in the next step of the workflow
    if ENV["CI"]
      sh "echo \"marketing-version=#{current_marketing_version}\" >> $GITHUB_OUTPUT"
    end
    
  end
end
